行優先(Row Major)と列優先(Column Major)について

・ベクトルとの計算
	4次元ベクトル(x, y, z, w)について、
	行優先では、1行4列行列
		| x y z w |
	と扱い、
	列優先では、4行1列行列
		| x |
		| y |
		| z |
		| w|
	と扱う。
	行列同士の乗算は(l行m列行列) * (m行n列行列) = (l行n列行列)であることから、
		行優先では (4次元ベクトル) * (4行4列行列)、
		列優先では (4行4列行列) * (4次元ベクトル)
	の順序で掛け合わせる必要がある。
	４行4列行列A, B, Cを順に4次元ベクトルへ掛け合わせる場合、
		行優先では (4次元ベクトル) * A * B * C、
		列優先では C * B * A * (4次元ベクトル)
	と計算する。

・メモリレイアウト
	float[16] = { 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15 }に対し、
	行優先では
		| 00 01 02 03 |
		| 04 05 06 07 |
		| 08 09 10 11 |
		| 12 13 14 15 |
	と扱い、
	列優先では
		| 00 04 08 12 |
		| 01 05 09 13 |
		| 02 06 10 14 |
		| 03 07 11 15 |
	と扱う。

・シェーダでの扱い
	HLSLとGLSLはともに列優先。CBVに設定されたfloat[16]配列を列優先の行列として扱う。
	列優先であるため、...*(行列)*(行列)*(ベクトル)の順で掛け合わせる。

・グラフィックAPIでの扱い
	DirectXでは行優先、OpenGLやVulkanでは列優先である。
	ただし、これはヘルパー関数などを使用して行列を生成した場合であって、上記のメモリレイアウトに従って列優先で定数バッファに送れば同じように処理できる。

・ローカル座標->ワールド座標への変換行列について
	頂点座標に対し、スケーリング、回転、平行移動を順に適用する。
	列優先のとき、
		(平行移動行列) * (回転行列) * (スケーリング行列) * (頂点座標)
	であり、
	平行移動(Tx, Ty, Tz)、回転クォータニオン(Rx, Ry, Rz, Rw)、スケール値(Sx, Sy, Sz)とすると、
	平行移動行列
		| 1 0 0 Tx	|
		| 0 1 0 Ty	|
		| 0 0 1 Yz	|
		| 0 0 0  1	|
	回転行列(Z軸、X軸、Y軸の順に回転を適用したもの)
		| Rw^2+Rx^2-Ry^2-Rz^2          2(RxRy-RzRw)                      2(RxRz+RyRw)             0 |
		|          2(RxRy+RzRw)             Rw^2-Rx^2+Ry^2-Rz^2         2(RyRz-RxRw)              0 |
		|          2(RxRz-RyRw)                  2(RyRz+RxRw)             Rw^2-Rx^2-Ry^2+Rz^2     0 |
		|                     0                                        0                                           0  					    1 |
	スケーリング行列
		| Sx   0   0   0 |
		|   0 Sy   0   0 |
		|   0   0 Sz   0 |
		|   0   0   0   1 |
	である。
	よって、回転行列のm行n列成分をRmnと表すと、変換行列は
		| SxR00 SyR01 SzR02 Tx	|
		| SxR10 SyR11 SzR12 Ty	|
		| SxR20 SyR21 SzR22 Tz	|
		|     0         0         0      1	|
	である。	
	ローカル座標系が親オブジェクトを持つとき、
		...(さらに親) * (親オブジェクトのローカル->ワールド変換行列) * (このオブジェクトのローカル->ワールド変換行列) * (頂点座標)
	となる。
	最終的なローカル->ワールド変換行列のm行n列成分をWmnと表すと、ローカル座標系の各軸はワールド座標系において、
		X軸 (W00, W10, W20)
		Y軸 (W01, W11, W21)
		Z軸 (W02, W12, W22)
	を向いていて、ローカル座標系の原点はワールド座標系において
		座標(W03, W13, W23)
	にあることがわかる。

・回転クォータニオンから回転行列を導出する方法について
	クォータニオン同士の乗算は
		Q1{ V1(x1, y1, z1), w1 } * Q2{ V2(x2, y2, z2), w2 } = Q{ w2V1 + w1V2 + Cross(V1, V2), w1w2 - Dot(V1, V2) }
	である。
	回転クォータニオンQ(Rx, Ry, Rz, Rw)をベクトルV(Vx, Vy, Vz)に適用した結果のベクトルV'(Vx', Vy', Vz')は、
		(Vx', Vy', Vz', 1) = (Rx, Ry, Rz, Rw) * (Vx, Vy, Vz, 1) * (-Rx, -Ry, -Rz, Rw)
	で求められる。
	このとき、
		Vx' = (Rw^2+Rx^2-Ry^2-Rz^2) * Vx + 2(RxRy-RzRw) * Vy + 2(RxRz+RyRw) * Vz
		Vy' = 2(RxRy+RzRw) * Vx + (Rw^2-Rx^2+Ry^2-Rz^2) * Vy + 2(RyRz-RxRw) * Vz
		Vz' = 2(RxRz-RyRw) * Vx + 2(RyRz+RxRw) * Vy + (Rw^2-Rx^2-Ry^2+Rz^2) * Vz
	であり、
		| Vx'	|	| Rw^2+Rx^2-Ry^2-Rz^2          2(RxRy-RzRw)                      2(RxRz+RyRw)             0	| | Vx |
		| Vy'	|=|          2(RxRy+RzRw)             Rw^2-Rx^2+Ry^2-Rz^2         2(RyRz-RxRw)              0	| | Vy |
		| Vz'	|=|          2(RxRz-RyRw)                  2(RyRz+RxRw)             Rw^2-Rx^2-Ry^2+Rz^2     0	| | Vz |
		|  1	|	|                     0                                        0                                           0  					    1	| |  1  |
	と分解できる。
	これは(回転適用後のベクトル)=(行列)*(ベクトル)の形であるため、この行列が回転行列だとわかる。

・ワールド座標->カメラ座標への変換行列(ビュー変換行列)について
	ワールド座標系の座標をカメラ座標系での座標に変換する。
	一般的に(親座標系での座標)=(ローカル座標->親座標への変換行列)*(ローカル座標系での座標)であり、また(行列A)*(行列Aの逆行列)=(単位行列)であるため、
		(ワールド座標系での座標)=(カメラ座標->ワールド座標への変換行列)*(カメラ座標系での座標)
		=> (カメラ座標->ワールド座標への変換行列の逆行列) * (ワールド座標系での座標)=(カメラ座標->ワールド座標への変換行列の逆行列) * (カメラ座標->ワールド座標への変換行列)*(カメラ座標系での座標)
		=> (カメラ座標->ワールド座標への変換行列の逆行列)*(ワールド座標系での座標)=(カメラ座標系での座標)
	であることがわかる。
	(カメラ座標->ワールド座標への変換行列)はカメラをワールド座標に置く変換行列であるため、
		(カメラ座標->ワールド座標への変換行列)=(カメラの平行移動行列)*(カメラの回転行列)*(カメラのスケーリング行列)
	であり、その逆行列は
		(カメラ座標->ワールド座標への変換行列の逆行列)=(カメラのスケーリング行列の逆行列)*(カメラの回転行列の逆行列)*(カメラの平行移動行列の逆行列)
	となる。
	それぞれの逆行列は逆変換と同義であり、
		スケール(Sx, Sy, Sz)に対する逆変換はスケール(1/Sx, 1/Sy, 1/Sz)、
		回転クォータニオン(Rx, Ry, Rz, Rw)に対する逆変換は回転クォータニオン(-Rx, -Ry, -Rz, Rw)、
		平行移動(Tx, Ty, Tz)に対する逆変換は平行移動(-Tx, -Ty, -Tz)
	となる。
	よって、ワールド座標->カメラ座標への変換行列(カメラのローカル座標->ワールド座標への変換行列の逆行列)は
		| R00/Sx R10/Sx R20/Sx -1/Sx(R00Tx+R10Ty+R20Tz)	|
		| R01/Sy R11/Sy R21/Sy -1/Sy(R01Tx+R11Ty+R21Tz)	|
		| R02/Sz R12/Sz R22/Sz -1/Sz(R02Tx+R12Ty+R22Tz)	|
		|     0           0           0                          1							|
	である。

・カメラ座標->クリップ座標への変換行列(射影変換行列)について
	以下の値を使用する。
		・nearZ		: 原点から最近面までの距離。カメラ座標系での描画領域の最小z値。
		・farZ		: 原点から最遠面までの距離。カメラ座標系での描画領域の最大z値。
		画角を指定する場合
			・aspect	: レンダーターゲットの縦横比。Height/Widthとする。
			・以下のいずれか
				・fovx	: 平行画角。オイラー角。
				・fovy	: 垂直画角。オイラー角。
		視錘台を指定する場合
			・left			: 最近面の左端のX座標。
			・right		: 最近面の右端のX座標。
			・top			: 最近面の上端のY座標。
			・bottom	: 最近面の下端のY座標。
	・最近面と最遠面について
		・Z軸と垂直な長方形である。
		・最近面と最遠面を底とする四角錐台内部をクリッピング空間の描画範囲に収まるように変換する。
		・レンダーターゲットと同じアスペクト比でない場合、拡縮されて見える。
		・画角を指定する場合、対角線の交点はZ軸を通る(対称な図形である)
	1. X、Y座標の変換について
		・画角を指定する場合
			左手座標系において、z[0, inf], h[0, inf]として、原点(0, 0, 0)、Z軸上の点(0, 0, z)、そのZ軸上の点を通るY軸に平行な直線と四角錐台の面の交点(0, h, z)を結んだ直角三角形を考える。
			原点(0, 0, 0)の角はfovy/2であるため、tan(fovy/2) = h/zである。(三角比の定義)
			この式をhについて整理すると、h = tan(fovy/2)*zとなる。
			また、Z軸上の点(0, 0, z)を通るX軸に平行な直線と四角錐台の面の交点(w, 0, z)を考えると、アスペクト比(aspect=Height/Width)から、
			w = h / aspect = tan(fovy/2)*z/aspectとわかる。
			なお、Z座標がzのときの四角錐台の断面の範囲はX座標[-w, w]、Y座標[-h, h]であることから、
			カメラ空間における描画範囲はX座標[-tan(fovy/2)*z/aspect, tan(fovy/2)*z/aspect]、Y座標[-tan(fovy/2)*z, tan(fovy/2)*z]となる。
			それぞれaspect/tan(fovy/2)、1/tan(fovy/2)をかけることで描画範囲を[-z, z]に変換できる。
			残ったzの値は処理する頂点座標固有のものであるため、後述のGPU処理にまかせることにする。
			・X、Y座標変換行列(fovy使用時)
				| aspect/tan(fovy/2)			0				0	0	|
				|			0						1/tan(fovy/2)	0	0	|
				|			0								0				1	0	|
				|			0								0				0	1	|

			また、同様にfovxを使用することを考えると、w = tan(fovx/2)*z、h = tan(fovx/2)*z*aspectとなる。
			カメラ空間における描画範囲はX座標[-tan(fovx/2)*z, tan(fovx/2)*z]、Y座標[-tan(fovx/2)*z*aspect, tan(fovx/2)*z*aspect]であるため、
			それぞれ1/tan(fovx/2)、1/(tan(fovx/2)*aspect)をかけることで描画範囲を[-z, z]に変換できる。
			・X、Y座標変換行列(fovx使用時)
				| 1/tan(fovx/2)					0						0	0	|
				|		0					1/(tan(fovx/2)*aspect)	0	0	|
				|		0									0						1	0	|
				|		0									0						0	1	|

		・視錘台を指定する場合
			最近面の頂点LT(left, top, nearZ)、LB(left, bottom, nearZ)、RB(right, bottom, nearZ)、RT(right, top, nearZ)と原点をそれぞれ直線で結ぶ。
			Z座標がz[0, inf]であったときの平面と上述の直線の交点をそれぞれLT'(l', t', z)、LB'(l', b', z)、RB'(r', b', z)、RT'(r', t', z)と置く。
			原点と最近面が作る四角錐Sと原点、LT'、LB'、RB'、RT'が作る四角錐S'は相似(最近面とz=zの平面が平行かつそれぞれの辺がすべて同一直線)であることから、
				nearZ : z = right : r' = left : l' = top : t' = bottom : b'
			となる。
			これらを整理して、
				r' = z*right/nearZ
				l' = z*left/nearZ
				t' = z*top/nearZ
				b' = z*bottom/nearZ
			である。
			R = -Lでないとき、視錘台は横方向に歪んでいるため、せん断変形によって中心に移動させなければならない。
			(r' + l')/2 = z*(right + left)/2nearZはX座標r'、l'の中間であり、これを0に向かって平行移動させればよいので、X座標の移動量は-z(right + left)/2nearZである。
			また、T = -Bでないとき、視錘台は縦方向に歪んでいるため、同様にしてY座標の移動量は-z(top + bottom)/2nearZである。
			なおこの変形はR = -L、T = -Bのときはそれぞれ移動量が0となる。
			・X、Y座標変換行列(視錘台せん断変形時)
				| 1	0	-(right + left)/2nearZ		0	|
				| 0	1	-(top + bottom)/2nearZ	0	|
				| 0	0						1					0	|
				| 0	0						0					1	|
				zを利用するために3列目(カメラ空間のz座標と乗算される)に平行移動成分を置く。

			ここからは、せん断変形によって上下左右が対象になった視錘台を考える。
			Z座標がzのときの視錘台の断面の幅Wと高さHはそれぞれ、
				W = r' - l' = z*(right - left)/nearZ
				H = t' - b' = z*(top - bottom)/nearZ
			であり、このときのカメラ空間における描画範囲はX座標[-W/2, W/2]、Y座標[-H/2, H/2]、
			すなわち[-z*(right - left)/2nearZ, z*(right - left)/2nearZ]、Y座標[-z*(top - bottom)/2nearZ, z*(top - bottom)/2nearZ]であるため、
			それぞれ2nearZ/(right - left)、2nearZ/(top - bottom)をかけることで描画範囲を[-z, z]に変換できる。
			・X、Y座標変換行列(視錘台指定時)
				| 2nearZ/(right - left)					0						0	0	|
				|				0					2nearZ/(top - bottom)	0	0	|
				|				0									0						1	0	|
				|				0									0						0	1	|


	2. Z座標の変換について
		Z座標を変換する行列は変数a, bを用いて以下のように定義できる。
			| 1	0	0	0	|
			| 0	1	0	0	|
			| 0	0	a	b	|
			| 0	0	1	0	|
			wにカメラ空間上のz座標を保持するため、4行目に手を加えてある。

		この行列をカメラ空間上の点(x, y, z, 1)に乗算して、(x, y, az + b, z)。
		GPUはすべての成分をw成分で除算し、クリッピング空間上の座標に変換するため、このときのz座標は(az + b)/zとなる。
		ここでカメラ空間におけるZ座標の描画範囲[nearZ, farZ]とクリッピング空間における描画範囲が一致するように
		変数a、bの値を求めればよい。
		・DirectX、Vulkanの場合
			クリッピング空間のZ座標の範囲は[0, 1]であり、0が手前、1が奥である。
			よって、z = nearZのとき、(az + b)/z = 0 かつ z = farZのとき、 (az + b)/z = 1となるから、
				(a * nearZ + b)/nearZ = 0 ...(1)
				(a * farZ + b)/farZ = 1
			の連立方程式が立てられる。
			(1)について、nearZ > 0であるから、両辺をnearZで割って
				a * nearZ + b = 0
			よって、
				a = farZ/(farZ - nearZ)
				b = -farZ*nearZ/(farZ - nearZ)
			となる。
		・OpenGLの場合
			クリッピング空間のZ座標の範囲は[-1, 1]であり、-1が手前、1が奥である。
			よって、z = nearZのとき、(az + b)/z = -1 かつ z = farZのとき、 (az + b)/z = 1となるから、
				(a * nearZ + b)/nearZ = -1
				(a * farZ + b)/farZ = 1
			の連立方程式が立てられる。
			これを解いて、
				a = (farZ+nearZ)/(farZ-nearZ)
				b = -2farZ*nearZ/(farZ-nearZ)
			となる。

	3. 変換をまとめる
		・fovx指定時 + DirectX、Vulkan使用時
			|	1/tan(fovx/2)					0								0											0							|
			|			0				1/(tan(fovx/2)*aspect)			0											0							|
			|			0								0						farZ/(farZ - nearZ)	-farZ * nearZ/(farZ - nearZ)	|
			|			0								0								1											0							|

		・fovy指定時 + DirectX、Vulkan使用時
			|	aspect/tan(fovy/2)			0							0										0							|
			|			0						1/tan(fovy/2)				0										0							|
			|			0								0				farZ/(farZ - nearZ)	-farZ * nearZ/(farZ - nearZ)	|
			|			0								0							1										0							|

		・視錘台指定時 + DirectX、Vulkan使用時
			| 2nearZ/(right - left)					0						-(right + left)/(right - left)								0							|
			|				0					2nearZ/(top - bottom)	-(top + bottom)/(top - bottom)						0							|
			|				0									0								farZ/(farZ - nearZ)				-farZ * nearZ/(farZ - nearZ)	|
			|				0									0											1													0							|

